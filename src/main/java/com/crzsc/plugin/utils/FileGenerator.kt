package com.crzsc.plugin.utils

import com.crzsc.plugin.utils.PluginUtils.showNotify
import com.crzsc.plugin.utils.PluginUtils.toLowCamelCase
import com.crzsc.plugin.utils.PluginUtils.toUpperCaseFirst
import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.project.Project
import com.intellij.openapi.project.guessModuleDir
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiManager

class FileGenerator(private val project: Project) {
    private val ignoreDir = listOf("2.0x", "3.0x", "Mx", "Nx")

    /**
     * 为所有模块重新生成
     */
    fun generateAll() {
        WriteCommandAction.runWriteCommandAction(project) {
            val assets = FileHelperNew.getAssets(project)
            if (assets.isEmpty()) {
                showNotify("Please configure your assets path in pubspec.yaml")
                return@runWriteCommandAction
            }
            for (config in assets) {
                generateWithConfig(config)
            }
        }
    }


    /**
     * 生成单个模块文件
     */
    fun generateOne(config: ModulePubSpecConfig) {
        WriteCommandAction.runWriteCommandAction(project) {
            generateWithConfig(config)
        }
    }

    private fun generateWithConfig(config: ModulePubSpecConfig) {
        val module = config.module
        val map = mutableMapOf<String, String>()
        val ignorePath = FileHelperNew.getPathIgnore(config)
        println("module $module config ${config.assetVFile} ignorePath $ignorePath")
        generateFileMap(
            config.assetVFile,
            config,
            map,
            ignorePath,
        )
        if (map.isEmpty()) {
            showNotify("assets path is empty")
            return
        }
        val content = StringBuilder()
        content.append("///This file is automatically generated. DO NOT EDIT, all your changes would be lost.\n")
        val className = FileHelperNew.getGeneratedClassName(config)
        content.append("class $className {\n  $className._();\n\n")
        map.toSortedMap().forEach {
            content.append("  static const String ${it.key} = '${it.value}';\n")
        }
        content.append("\n}\n")
        val psiManager = PsiManager.getInstance(project)
        val psiDocumentManager = PsiDocumentManager.getInstance(project)
        FileHelperNew.getGeneratedFile(config).let { generated ->
            psiManager.findFile(generated)?.let { dartFile ->
                psiDocumentManager.getDocument(dartFile)?.let { document ->
                    if (document.text != content.toString()) {
                        document.setText(content)
                        psiDocumentManager.commitDocument(document)
                        showNotify("$module : assets generate succeed")
                    } else {
                        showNotify("$module : nothing changed")
                    }
                }
            }
        }
    }

    private fun generateFileMap(
        root: VirtualFile,
        config: ModulePubSpecConfig,
        map: MutableMap<String, String>,
        ignorePath: List<String>,
    ) {
        val namedWithParent = FileHelperNew.isNamedWithParent(config)
        val pattern = FileHelperNew.getFilenameSplitPattern(config)
        val basePath = config.module.guessModuleDir()?.path
        val regex = Regex(pattern)
        root.children.filter {
            var pathIgnore = false
            if (ignorePath.isNotEmpty()) {
                for (name in ignorePath) {
                    if (it.path.contains(name, ignoreCase = true)) {
                        pathIgnore = true
                        println("${it.path} pathIgnore : $pathIgnore")
                        break
                    }
                }
            }
            !it.name.startsWith('.') && checkName(it.name) && !pathIgnore
        }.forEach {
            if (it.isDirectory) {
                generateFileMap(it, config, map, ignorePath)
            } else {
                var key = it.nameWithoutExtension.toLowCamelCase(regex)///fileName style
                val value = it.path.removePrefix("$basePath/")
                if (namedWithParent) {
                    it.parent?.let { parent ->
                        key = "${parent.name.toLowCamelCase(regex)}${key.toUpperCaseFirst()}"
                        if (map.containsKey(key)) {
                            key = "${parent.parent.name.toLowCamelCase(regex)}${key.toUpperCaseFirst()}"
                        }
                        map[key] = value
                    }
                } else {
                    map[key] = value
                }
            }
        }
    }

    private fun checkName(name: String): Boolean {
        return !ignoreDir.contains(name)
    }

}